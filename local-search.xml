<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式（二）之设计原则</title>
    <link href="/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="设计原则-SOLID"><a href="#设计原则-SOLID" class="headerlink" title="设计原则 (SOLID)"></a>设计原则 (SOLID)</h2><blockquote><ul><li>单一职责原则 Single resposibility principle</li><li>开放封闭原则 Open-closed principle</li><li>里氏替换原则 Liskov substitution principle</li><li>接口隔离原则 Interface segregation principle</li><li>依赖倒置原则 Dependency inversion principle</li></ul>设计原则存在的目的时提供一种指导思想，使得程序开发过程中的代码，更具有可读性、灵活性、可维护性。</blockquote><h4 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h4><blockquote><p>单一职责原则要求类和模块应该只做一件事<br>单一职责不仅仅只是针对类而言，同样适用于各个层级的结构，比如单个方法或者整个项目。</p></blockquote><p>单一职责原则是一种指导性的意见，也就是说需要根据项目的实际需要，灵活的决定是否需要遵循单一职责原则： </p><ul><li><b>如果类型足够简单，可以违背单一职责原则，因为单一职责会增加代码量</b></li><li><b>如果类型复杂，就适合使用单一职责原则</b></li></ul><h4 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h4><blockquote><p>软件实体（模块、类、方法等）应该对“扩展开放，对修改关闭”</p></blockquote><p>应该对可以预见的模块开辟扩展点，但是需要考虑时间人力成本，未知的扩展是没必要的</p><h4 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h4><blockquote><p>子类对象能够替换程序中父类对象出现的任何地方，并且保证越来程序的逻辑行为不变及正确性不被破坏</p></blockquote><p>强调基类的表达能力</p><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Retangle</span><br>&#123;<br>    <span class="hljs-comment">//父类中虚方法进行描述</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">int</span> Width &#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">int</span> Height &#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> : <span class="hljs-title">Retangle</span><br>&#123;<br>    <span class="hljs-comment">//子类重写父类中的属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> Width <br>    &#123;<br>        <span class="hljs-keyword">set</span>&#123;<span class="hljs-keyword">base</span>.Width = <span class="hljs-keyword">base</span>.Height = <span class="hljs-keyword">value</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> Height<br>    &#123;<br>        <span class="hljs-keyword">set</span>&#123;<span class="hljs-keyword">base</span>.Width = <span class="hljs-keyword">base</span>.Height = <span class="hljs-keyword">value</span>;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Area</span>(<span class="hljs-params">Retangle r</span>)</span> =&gt; r.Width * r.Height;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Retangle r = <span class="hljs-keyword">new</span> Square()&#123;Width = <span class="hljs-number">3</span>&#125;;<br>        Area(r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h4><blockquote><p>不要对外暴露没有实际意义的接口，把大的接口分割成小的接口</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs csharp"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPrinter</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IScaner</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Scan</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IFax</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fax</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">INewMachine</span> : <span class="hljs-title">IPrinter</span>, <span class="hljs-title">IScaner</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OldMachine</span> : <span class="hljs-title">IPrinter</span><br>&#123;<br>    IPrinter _printer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OldMachine</span>(<span class="hljs-params">IPrinter printer</span>)</span><br>    &#123;<br>        printer = printer ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        _printer.Print()<br>    &#125;   <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NewMachine</span> : <span class="hljs-title">INewMachine</span><br>&#123;<br>    IPrinter _printer;<br>    IScaner _scaner;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NewMachine</span>(<span class="hljs-params">IPrinter printer, IScaner scaner</span>)</span><br>    &#123;<br>        _printer = printer ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>        _scaner = scaner ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        _printer.Print();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Scan</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        _scaner.Scan();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h4><blockquote><p>高层模块不应该依赖低层模块，二者都应该依赖于抽象。</p></blockquote><p>依赖倒转原则的核心在于面向接口编程。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP-Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式（一）之单例模式</title>
    <link href="/2022/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><h3><b><font color=blue>什么是单例模式？</font></b></h3><blockquote><p>单例模式顾名思义就是在整个运行时域，一个类只有一个实例对象，并且提供一个全局访问点。</p></blockquote><h3><b><font color=blue>为什么需要单例模式？</font></b></h3><blockquote><p>在软件开发过程中，有的实例对象比较重量级，创建或销毁都会消耗较多的资源。<br>必须保证系统中只存在一个实例对象，才能确保它的逻辑正确性。<br>以上要求应该是类的设计者的责任，而不是类的使用者的责任。</p></blockquote><h3><b><font color=blue>单例模式的实现方式</font></b></h3><h4 id="懒加载（线程不安全）"><a href="#懒加载（线程不安全）" class="headerlink" title="懒加载（线程不安全）"></a>懒加载（线程不安全）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-comment">//不允许外部实例化该类</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>    <span class="hljs-comment">//初始化对象为null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//提供全局访问点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>        &#123;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是单例模式的懒加载，当调用时才实例出一个对象，但是这无法在实际项目中使用，因为在多线程中，会创建多个实例。 </p><h4 id="懒加载（线程安全）"><a href="#懒加载（线程安全）" class="headerlink" title="懒加载（线程安全）"></a>懒加载（线程安全）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-comment">//不允许外部实例化该类</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>    <span class="hljs-comment">//初始化对象为null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//线程同步辅助对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> SingletonLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>    <span class="hljs-comment">//提供全局访问点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加锁处理确保同一时刻只有一个线程访问</span><br>        <span class="hljs-keyword">lock</span>(SingletonLock)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>            &#123;<br>                instance = <span class="hljs-keyword">new</span> Singleton();<br>            &#125;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> instance;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中实现了单例模式的线程锁，这确保了不会因为多线程而产生多个实例对象。但是由于每次获取实例对象时都需要先获取锁，这会导致代码低效运行，还是避免不要不必要的资源开支。</p><h4 id="懒加载（双检锁）"><a href="#懒加载（双检锁）" class="headerlink" title="懒加载（双检锁）"></a>懒加载（双检锁）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-comment">//不允许外部实例化该类</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>    <span class="hljs-comment">//初始化对象为null</span><br>    <span class="hljs-comment">//volatile指令重排</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//线程同步辅助对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> SingletonLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>    <span class="hljs-comment">//提供全局访问点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//先判断是否已有实例对象，避免多次获取线程锁</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-comment">//加锁处理确保同一时刻只有一个线程访问</span><br>            <span class="hljs-keyword">lock</span>(SingletonLock)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>                &#123;<br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;         <br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;     <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在这段代码已经基本实现了单例模式的目的，保证了一个运行时中只存在一个实例对象，并提供了一个访问点。满足了对单例模式的要求：<br><strong>懒加载</strong><br><strong>线程安全</strong></p><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-comment">//不允许外部实例化对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>    <span class="hljs-comment">//第一次引用类的任何成员时便创建实例，CLR负责处理变量初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    <span class="hljs-comment">//提供全局访问点 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Static Singleton <span class="hljs-title">GetInstance</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-comment">//不允许外部实例化对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>    <span class="hljs-comment">//第一次引用类的任何成员时便创建实例，CLR负责处理变量初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Singleton instance;<br>    <span class="hljs-comment">//静态构造器</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-comment">//提供全局访问点 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Static Singleton <span class="hljs-title">GetInstance</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际运用中，这段代码也实现了单例模式的目的。这种方法也是线程安全的。.Net中保证静态构造器只会被一个线程执行。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP-Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello My Blog</title>
    <link href="/2022/01/04/Hello-My-Blog/"/>
    <url>/2022/01/04/Hello-My-Blog/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇笔记发布"><a href="#第一篇笔记发布" class="headerlink" title="第一篇笔记发布"></a><strong>第一篇笔记发布</strong></h1><p>通过Hexo建立的第一个Blog，用于记录学习心得，后续主要归类为<ul><li><strong>C#基础</strong></li><li><strong>数据结构</strong></li><li><strong>网络通讯</strong></li><li><strong>数据库</strong></li><li><strong>WPF</strong></li><li><strong>设计模式</strong></li></ul></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>首发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
