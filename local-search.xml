<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式（一）之单例模式</title>
    <link href="/2022/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><h3><b><font color=blue>什么是单例模式？</font></b></h3><blockquote><p>单例模式顾名思义就是在整个运行时域，一个类只有一个实例对象，并且提供一个全局访问点。</p></blockquote><h3><b><font color=blue>为什么需要单例模式？</font></b></h3><blockquote><p>在软件开发过程中，有的实例对象比较重量级，创建或销毁都会消耗较多的资源。<br>必须保证系统中只存在一个实例对象，才能确保它的逻辑正确性。<br>以上要求应该是类的设计者的责任，而不是类的使用者的责任。</p></blockquote><h3><b><font color=blue>单例模式的实现方式</font></b></h3>#### 懒加载（线程不安全）<figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-comment">//不允许外部实例化该类</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>    <span class="hljs-comment">//初始化对象为null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//提供全局访问点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>        &#123;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这是单例模式的懒加载，当调用时才实例出一个对象，但是这无法在实际项目中使用，因为在多线程中，会创建多个实例。 <h4 id="懒加载（线程安全）"><a href="#懒加载（线程安全）" class="headerlink" title="懒加载（线程安全）"></a>懒加载（线程安全）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-comment">//不允许外部实例化该类</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>    <span class="hljs-comment">//初始化对象为null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//线程同步辅助对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> SingletonLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>    <span class="hljs-comment">//提供全局访问点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//加锁处理确保同一时刻只有一个线程访问</span><br>        <span class="hljs-keyword">lock</span>(SingletonLock)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>            &#123;<br>                instance = <span class="hljs-keyword">new</span> Singleton();<br>            &#125;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> instance;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中实现了单例模式的线程锁，这确保了不会因为多线程而产生多个实例对象。但是由于每次获取实例对象时都需要先获取锁，这会导致代码低效运行，还是避免不要不必要的资源开支。</p><h4 id="懒加载（双检锁）"><a href="#懒加载（双检锁）" class="headerlink" title="懒加载（双检锁）"></a>懒加载（双检锁）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-comment">//不允许外部实例化该类</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>    <span class="hljs-comment">//初始化对象为null</span><br>    <span class="hljs-comment">//volatile指令重排</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//线程同步辅助对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> SingletonLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>    <span class="hljs-comment">//提供全局访问点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">GetInstance</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//先判断是否已有实例对象，避免多次获取线程锁</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-comment">//加锁处理确保同一时刻只有一个线程访问</span><br>            <span class="hljs-keyword">lock</span>(SingletonLock)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>                &#123;<br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;         <br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;     <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在这段代码已经基本实现了单例模式的目的，保证了一个运行时中只存在一个实例对象，并提供了一个访问点。满足了对单例模式的要求：<br><strong>懒加载</strong><br><strong>线程安全</strong></p><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-comment">//不允许外部实例化对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>    <span class="hljs-comment">//第一次引用类的任何成员时便创建实例，CLR负责处理变量初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    <span class="hljs-comment">//提供全局访问点 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Static Singleton <span class="hljs-title">GetInstance</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span><br>&#123;<br>    <span class="hljs-comment">//不允许外部实例化对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>    <span class="hljs-comment">//第一次引用类的任何成员时便创建实例，CLR负责处理变量初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Singleton instance;<br>    <span class="hljs-comment">//静态构造器</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-comment">//提供全局访问点 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Static Singleton <span class="hljs-title">GetInstance</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际运用中，这段代码也实现了单例模式的目的。这种方法也是线程安全的。.Net中保证静态构造器只会被一个线程执行。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP-Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello My Blog</title>
    <link href="/2022/01/04/Hello-My-Blog/"/>
    <url>/2022/01/04/Hello-My-Blog/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇笔记发布"><a href="#第一篇笔记发布" class="headerlink" title="第一篇笔记发布"></a><strong>第一篇笔记发布</strong></h1><p>通过Hexo建立的第一个Blog，用于记录学习心得，后续主要归类为<ul><li><strong>C#基础</strong></li><li><strong>数据结构</strong></li><li><strong>网络通讯</strong></li><li><strong>数据库</strong></li><li><strong>WPF</strong></li><li><strong>设计模式</strong></li></ul></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>首发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
